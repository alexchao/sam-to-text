# -*- coding: utf-8 -*-
import json

from sam_to_text.processors.transcript_chunker import TranscriptChunker


def _check_result_status(result, result_transcript):
    if len(result['alternatives']) > 1:
        raise Exception('Found > 1 alternatives for result: {}'.format(
            result_transcript))
    if not result['final']:
        raise Exception('Found non-final result: {}'.format(
            result_transcript))


def process_watson_transcript(config):
    """Process a transcript generated by the IBM Watson speech recognize API.
    """
    chunker = TranscriptChunker()

    # TODO: don't assume 1 file
    file_path = config.source_files[0]
    with open(file_path, 'r') as f:
        result_json = json.loads(f.read())

    speaker_labels = {
        label['from']: label for label in result_json['speaker_labels']
    }

    for result in result_json['results']:
        best_result = result['alternatives'][0]
        _check_result_status(result, best_result['transcript'])
        transcript_html = make_html_from_result(
            best_result,
            config,
            speaker_labels)
        chunker.add_transcript(best_result['transcript'], transcript_html)

    return chunker.get_chunks()


def _group_speaker_utterances(timestamps, word_confidence, speaker_labels):
    dialogue = []
    speaker_id = None
    utterances = []
    for i, timestamp in enumerate(timestamps):
        utterance, ts_from, _ = timestamp
        new_speaker_id = speaker_labels[ts_from]['speaker']
        if speaker_id is None:
            speaker_id = new_speaker_id
        elif speaker_id != new_speaker_id:
            dialogue.append({'speaker_id': speaker_id, 'utterances': utterances})
            speaker_id = new_speaker_id
            utterances = []

        if timestamp[0] != word_confidence[i][0]:
            raise Exception(
                'Found timestamp-word_confidence mismatch: {}'.format(
                    timestamp[0] + ' =/= ' + word_confidence[i][0]))

        utterances.append({
            'word': timestamp[0],
            'confidence': word_confidence[i][1]
        })

    dialogue.append({'speaker_id': speaker_id, 'utterances': utterances})
    return dialogue


def make_html_from_result(result, config, speaker_labels):
    dialogue = _group_speaker_utterances(
        result['timestamps'],
        result['word_confidence'],
        speaker_labels)

    full_html = ''
    for speech in dialogue:
        speaker_name = config.extra['speakers'][str(speech['speaker_id'])]
        words = []
        for utterance in speech['utterances']:
            confidence = utterance['confidence']
            word = utterance['word']
            if confidence < 0.2:
                words.append('<span class="confidence-poor">{}</span>'.format(
                    word))
            elif confidence < 0.4:
                words.append('<span class="confidence-low">{}</span>'.format(
                    word))
            else:
                words.append(word)

        full_html += '<p><span class="speaker-name">{speaker}</span>: {words}</p>'.format(
            speaker=speaker_name,
            words=' '.join(words))

    return full_html
